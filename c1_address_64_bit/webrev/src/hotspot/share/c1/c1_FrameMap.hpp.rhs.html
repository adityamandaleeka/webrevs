<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_C1_C1_FRAMEMAP_HPP
  26 #define SHARE_C1_C1_FRAMEMAP_HPP
  27 
  28 #include "asm/macroAssembler.hpp"
  29 #include "c1/c1_Defs.hpp"
  30 #include "c1/c1_LIR.hpp"
  31 #include "code/vmreg.hpp"
  32 #include "memory/allocation.hpp"
  33 #include "runtime/frame.hpp"
  34 #include "runtime/synchronizer.hpp"
  35 #include "utilities/globalDefinitions.hpp"
  36 #include "utilities/macros.hpp"
  37 
  38 class ciMethod;
  39 class CallingConvention;
  40 
  41 //--------------------------------------------------------
  42 //               FrameMap
  43 //--------------------------------------------------------
  44 
  45 //  This class is responsible of mapping items (locals, monitors, spill
  46 //  slots and registers to their frame location
  47 //
  48 //  The monitors are specified by a consecutive index, although each monitor entry
  49 //  occupies two words. The monitor_index is 0.._num_monitors
  50 //  The spill index is similar to local index; it is in range 0..(open)
  51 //
  52 //  The CPU registers are mapped using a fixed table; register with number 0
  53 //  is the most used one.
  54 
  55 
  56 //   stack grow direction --&gt;                                        SP
  57 //  +----------+---+----------+-------+------------------------+-----+
  58 //  |arguments | x | monitors | spill | reserved argument area | ABI |
  59 //  +----------+---+----------+-------+------------------------+-----+
  60 //
  61 //  x =  ABI area (SPARC) or  return adress and link (i486)
  62 //  ABI  = ABI area (SPARC) or nothing (i486)
  63 
  64 
  65 class LIR_OprDesc;
  66 typedef LIR_OprDesc* LIR_Opr;
  67 
  68 
  69 class FrameMap : public CompilationResourceObj {
  70  public:
  71   enum {
  72     nof_cpu_regs = pd_nof_cpu_regs_frame_map,
  73     nof_fpu_regs = pd_nof_fpu_regs_frame_map,
  74 
  75     nof_cpu_regs_reg_alloc = pd_nof_cpu_regs_reg_alloc,
  76     nof_fpu_regs_reg_alloc = pd_nof_fpu_regs_reg_alloc,
  77 
  78     max_nof_caller_save_cpu_regs = pd_nof_caller_save_cpu_regs_frame_map,
  79     nof_caller_save_fpu_regs     = pd_nof_caller_save_fpu_regs_frame_map,
  80 
  81     spill_slot_size_in_bytes = 4
  82   };
  83 
  84 #include CPU_HEADER(c1_FrameMap)
  85 
  86   friend class LIR_OprDesc;
  87 
  88  private:
  89   static bool         _init_done;
  90   static Register     _cpu_rnr2reg [nof_cpu_regs];
  91   static int          _cpu_reg2rnr [nof_cpu_regs];
  92 
  93   static LIR_Opr      _caller_save_cpu_regs [max_nof_caller_save_cpu_regs];
  94   static LIR_Opr      _caller_save_fpu_regs [nof_caller_save_fpu_regs];
  95 
  96   int                 _framesize;
  97   int                 _argcount;
  98   int                 _num_monitors;
  99   int                 _num_spills;
 100   int                 _reserved_argument_area_size;
 101   int                 _oop_map_arg_count;
 102 
 103   CallingConvention*  _incoming_arguments;
 104   intArray*           _argument_locations;
 105 
 106   void check_spill_index   (int spill_index)   const { assert(spill_index   &gt;= 0, "bad index"); }
 107   void check_monitor_index (int monitor_index) const { assert(monitor_index &gt;= 0 &amp;&amp;
 108                                                               monitor_index &lt; _num_monitors, "bad index"); }
 109 
 110   static Register cpu_rnr2reg (int rnr) {
 111     assert(_init_done, "tables not initialized");
 112     debug_only(cpu_range_check(rnr);)
 113     return _cpu_rnr2reg[rnr];
 114   }
 115 
 116   static int cpu_reg2rnr (Register reg) {
 117     assert(_init_done, "tables not initialized");
 118     debug_only(cpu_range_check(reg-&gt;encoding());)
 119     return _cpu_reg2rnr[reg-&gt;encoding()];
 120   }
 121 
 122   static void map_register(int rnr, Register reg) {
 123     debug_only(cpu_range_check(rnr);)
 124     debug_only(cpu_range_check(reg-&gt;encoding());)
 125     _cpu_rnr2reg[rnr] = reg;
 126     _cpu_reg2rnr[reg-&gt;encoding()] = rnr;
 127   }
 128 
 129   void update_reserved_argument_area_size (int size) {
 130     assert(size &gt;= 0, "check");
 131     _reserved_argument_area_size = MAX2(_reserved_argument_area_size, size);
 132   }
 133 
 134  protected:
 135 #ifndef PRODUCT
 136   static void cpu_range_check (int rnr)          { assert(0 &lt;= rnr &amp;&amp; rnr &lt; nof_cpu_regs, "cpu register number is too big"); }
 137   static void fpu_range_check (int rnr)          { assert(0 &lt;= rnr &amp;&amp; rnr &lt; nof_fpu_regs, "fpu register number is too big"); }
 138 #endif
 139 
 140 
 141   ByteSize sp_offset_for_monitor_base(const int idx) const;
 142 
 143   Address make_new_address(ByteSize sp_offset) const;
 144 
 145   ByteSize sp_offset_for_slot(const int idx) const;
 146   ByteSize sp_offset_for_double_slot(const int idx) const;
 147   ByteSize sp_offset_for_spill(const int idx) const;
 148   ByteSize sp_offset_for_monitor_lock(int monitor_index) const;
 149   ByteSize sp_offset_for_monitor_object(int monitor_index) const;
 150 
 151   VMReg sp_offset2vmreg(ByteSize offset) const;
 152 
 153   // platform dependent hook used to check that frame is properly
 154   // addressable on the platform.  Used by sparc to verify that all
 155   // stack addresses are expressable in a simm13.
 156   bool validate_frame();
 157 
 158   static LIR_Opr map_to_opr(BasicType type, VMRegPair* reg, bool incoming);
 159 
 160  public:
 161   // Opr representing the stack_pointer on this platform
 162   static LIR_Opr stack_pointer();
 163 
 164   // JSR 292
 165   static LIR_Opr method_handle_invoke_SP_save_opr();
 166 
 167   static BasicTypeArray*     signature_type_array_for(const ciMethod* method);
 168 
 169   // for outgoing calls, these also update the reserved area to
 170   // include space for arguments and any ABI area.
 171   CallingConvention* c_calling_convention(const BasicTypeArray* signature);
 172   CallingConvention* java_calling_convention(const BasicTypeArray* signature, bool outgoing);
 173 
 174   // deopt support
 175   ByteSize sp_offset_for_orig_pc() { return sp_offset_for_monitor_base(_num_monitors); }
 176 
 177   static LIR_Opr as_opr(Register r) {
 178     return LIR_OprFact::single_cpu(cpu_reg2rnr(r));
 179   }
 180   static LIR_Opr as_oop_opr(Register r) {
 181     return LIR_OprFact::single_cpu_oop(cpu_reg2rnr(r));
 182   }
 183 
 184   static LIR_Opr as_metadata_opr(Register r) {
 185     return LIR_OprFact::single_cpu_metadata(cpu_reg2rnr(r));
 186   }
 187 
<a name="1" id="anc1"></a><span class="new"> 188   static LIR_Opr as_address_opr(Register r) {</span>
<span class="new"> 189     return LIR_OprFact::single_cpu_address(cpu_reg2rnr(r));</span>
<span class="new"> 190   }</span>
<span class="new"> 191 </span>
 192   FrameMap(ciMethod* method, int monitors, int reserved_argument_area_size);
 193   bool finalize_frame(int nof_slots);
 194 
 195   int   reserved_argument_area_size () const     { return _reserved_argument_area_size; }
 196   int   framesize                   () const     { assert(_framesize != -1, "hasn't been calculated"); return _framesize; }
 197   ByteSize framesize_in_bytes       () const     { return in_ByteSize(framesize() * 4); }
 198   int   num_monitors                () const     { return _num_monitors; }
 199   int   num_spills                  () const     { assert(_num_spills &gt;= 0, "not set"); return _num_spills; }
 200   int   argcount              () const     { assert(_argcount &gt;= 0, "not set"); return _argcount; }
 201 
 202   int oop_map_arg_count() const { return _oop_map_arg_count; }
 203 
 204   CallingConvention* incoming_arguments() const  { return _incoming_arguments; }
 205 
 206   // convenience routines
 207   Address address_for_slot(int index, int sp_adjust = 0) const {
 208     return make_new_address(sp_offset_for_slot(index) + in_ByteSize(sp_adjust));
 209   }
 210   Address address_for_double_slot(int index, int sp_adjust = 0) const {
 211     return make_new_address(sp_offset_for_double_slot(index) + in_ByteSize(sp_adjust));
 212   }
 213   Address address_for_monitor_lock(int monitor_index) const {
 214     return make_new_address(sp_offset_for_monitor_lock(monitor_index));
 215   }
 216   Address address_for_monitor_object(int monitor_index) const {
 217     return make_new_address(sp_offset_for_monitor_object(monitor_index));
 218   }
 219 
 220   // Creates Location describing desired slot and returns it via pointer
 221   // to Location object. Returns true if the stack frame offset was legal
 222   // (as defined by Location::legal_offset_in_bytes()), false otherwise.
 223   // Do not use the returned location if this returns false.
 224   bool location_for_sp_offset(ByteSize byte_offset_from_sp,
 225                               Location::Type loc_type, Location* loc) const;
 226 
 227   bool location_for_monitor_lock  (int monitor_index, Location* loc) const {
 228     return location_for_sp_offset(sp_offset_for_monitor_lock(monitor_index), Location::normal, loc);
 229   }
 230   bool location_for_monitor_object(int monitor_index, Location* loc) const {
 231     return location_for_sp_offset(sp_offset_for_monitor_object(monitor_index), Location::oop, loc);
 232   }
 233   bool locations_for_slot  (int index, Location::Type loc_type,
 234                             Location* loc, Location* second = NULL) const;
 235 
 236   VMReg slot_regname(int index) const {
 237     return sp_offset2vmreg(sp_offset_for_slot(index));
 238   }
 239   VMReg monitor_object_regname(int monitor_index) const {
 240     return sp_offset2vmreg(sp_offset_for_monitor_object(monitor_index));
 241   }
 242   VMReg regname(LIR_Opr opr) const;
 243 
 244   static LIR_Opr caller_save_cpu_reg_at(int i) {
 245     assert(i &gt;= 0 &amp;&amp; i &lt; max_nof_caller_save_cpu_regs, "out of bounds");
 246     return _caller_save_cpu_regs[i];
 247   }
 248 
 249   static LIR_Opr caller_save_fpu_reg_at(int i) {
 250     assert(i &gt;= 0 &amp;&amp; i &lt; nof_caller_save_fpu_regs, "out of bounds");
 251     return _caller_save_fpu_regs[i];
 252   }
 253 
 254   static void initialize();
 255 };
 256 
 257 //               CallingConvention
 258 //--------------------------------------------------------
 259 
 260 class CallingConvention: public ResourceObj {
 261  private:
 262   LIR_OprList* _args;
 263   int          _reserved_stack_slots;
 264 
 265  public:
 266   CallingConvention (LIR_OprList* args, int reserved_stack_slots)
 267     : _args(args)
 268     , _reserved_stack_slots(reserved_stack_slots)  {}
 269 
 270   LIR_OprList* args()       { return _args; }
 271 
 272   LIR_Opr at(int i) const   { return _args-&gt;at(i); }
 273   int length() const        { return _args-&gt;length(); }
 274 
 275   // Indicates number of real frame slots used by arguments passed on stack.
 276   int reserved_stack_slots() const            { return _reserved_stack_slots; }
 277 
 278 #ifndef PRODUCT
 279   void print () const {
 280     for (int i = 0; i &lt; length(); i++) {
 281       at(i)-&gt;print();
 282     }
 283   }
 284 #endif // PRODUCT
 285 };
 286 
 287 #endif // SHARE_C1_C1_FRAMEMAP_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>
