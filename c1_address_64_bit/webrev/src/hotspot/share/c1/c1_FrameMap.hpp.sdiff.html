<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>jdk Sdiff src/hotspot/share/c1 </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> next &gt</center>
<h2>src/hotspot/share/c1/c1_FrameMap.hpp</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre></pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
 168 
 169   // for outgoing calls, these also update the reserved area to
 170   // include space for arguments and any ABI area.
 171   CallingConvention* c_calling_convention(const BasicTypeArray* signature);
 172   CallingConvention* java_calling_convention(const BasicTypeArray* signature, bool outgoing);
 173 
 174   // deopt support
 175   ByteSize sp_offset_for_orig_pc() { return sp_offset_for_monitor_base(_num_monitors); }
 176 
 177   static LIR_Opr as_opr(Register r) {
 178     return LIR_OprFact::single_cpu(cpu_reg2rnr(r));
 179   }
 180   static LIR_Opr as_oop_opr(Register r) {
 181     return LIR_OprFact::single_cpu_oop(cpu_reg2rnr(r));
 182   }
 183 
 184   static LIR_Opr as_metadata_opr(Register r) {
 185     return LIR_OprFact::single_cpu_metadata(cpu_reg2rnr(r));
 186   }
 187 




 188   FrameMap(ciMethod* method, int monitors, int reserved_argument_area_size);
 189   bool finalize_frame(int nof_slots);
 190 
 191   int   reserved_argument_area_size () const     { return _reserved_argument_area_size; }
 192   int   framesize                   () const     { assert(_framesize != -1, "hasn't been calculated"); return _framesize; }
 193   ByteSize framesize_in_bytes       () const     { return in_ByteSize(framesize() * 4); }
 194   int   num_monitors                () const     { return _num_monitors; }
 195   int   num_spills                  () const     { assert(_num_spills &gt;= 0, "not set"); return _num_spills; }
 196   int   argcount              () const     { assert(_argcount &gt;= 0, "not set"); return _argcount; }
 197 
 198   int oop_map_arg_count() const { return _oop_map_arg_count; }
 199 
 200   CallingConvention* incoming_arguments() const  { return _incoming_arguments; }
 201 
 202   // convenience routines
 203   Address address_for_slot(int index, int sp_adjust = 0) const {
 204     return make_new_address(sp_offset_for_slot(index) + in_ByteSize(sp_adjust));
 205   }
 206   Address address_for_double_slot(int index, int sp_adjust = 0) const {
 207     return make_new_address(sp_offset_for_double_slot(index) + in_ByteSize(sp_adjust));

</pre><hr></hr>
</pre></td><td><pre>

</pre><hr></hr><pre>
 168 
 169   // for outgoing calls, these also update the reserved area to
 170   // include space for arguments and any ABI area.
 171   CallingConvention* c_calling_convention(const BasicTypeArray* signature);
 172   CallingConvention* java_calling_convention(const BasicTypeArray* signature, bool outgoing);
 173 
 174   // deopt support
 175   ByteSize sp_offset_for_orig_pc() { return sp_offset_for_monitor_base(_num_monitors); }
 176 
 177   static LIR_Opr as_opr(Register r) {
 178     return LIR_OprFact::single_cpu(cpu_reg2rnr(r));
 179   }
 180   static LIR_Opr as_oop_opr(Register r) {
 181     return LIR_OprFact::single_cpu_oop(cpu_reg2rnr(r));
 182   }
 183 
 184   static LIR_Opr as_metadata_opr(Register r) {
 185     return LIR_OprFact::single_cpu_metadata(cpu_reg2rnr(r));
 186   }
 187 
<span class="new"> 188   static LIR_Opr as_address_opr(Register r) {</span>
<span class="new"> 189     return LIR_OprFact::single_cpu_address(cpu_reg2rnr(r));</span>
<span class="new"> 190   }</span>
<span class="new"> 191 </span>
 192   FrameMap(ciMethod* method, int monitors, int reserved_argument_area_size);
 193   bool finalize_frame(int nof_slots);
 194 
 195   int   reserved_argument_area_size () const     { return _reserved_argument_area_size; }
 196   int   framesize                   () const     { assert(_framesize != -1, "hasn't been calculated"); return _framesize; }
 197   ByteSize framesize_in_bytes       () const     { return in_ByteSize(framesize() * 4); }
 198   int   num_monitors                () const     { return _num_monitors; }
 199   int   num_spills                  () const     { assert(_num_spills &gt;= 0, "not set"); return _num_spills; }
 200   int   argcount              () const     { assert(_argcount &gt;= 0, "not set"); return _argcount; }
 201 
 202   int oop_map_arg_count() const { return _oop_map_arg_count; }
 203 
 204   CallingConvention* incoming_arguments() const  { return _incoming_arguments; }
 205 
 206   // convenience routines
 207   Address address_for_slot(int index, int sp_adjust = 0) const {
 208     return make_new_address(sp_offset_for_slot(index) + in_ByteSize(sp_adjust));
 209   }
 210   Address address_for_double_slot(int index, int sp_adjust = 0) const {
 211     return make_new_address(sp_offset_for_double_slot(index) + in_ByteSize(sp_adjust));

</pre><hr></hr>
</pre></td>
</tr></table>
<center><a href='../../../../src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> next &gt</center>
</body></html>
