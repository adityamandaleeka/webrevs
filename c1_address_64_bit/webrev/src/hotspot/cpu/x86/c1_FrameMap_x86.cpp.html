<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/hotspot/cpu/x86/c1_FrameMap_x86.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include "precompiled.hpp"
  26 #include "c1/c1_FrameMap.hpp"
  27 #include "c1/c1_LIR.hpp"
  28 #include "runtime/sharedRuntime.hpp"
  29 #include "vmreg_x86.inline.hpp"
  30 
  31 const int FrameMap::pd_c_runtime_reserved_arg_size = 0;
  32 
  33 LIR_Opr FrameMap::map_to_opr(BasicType type, VMRegPair* reg, bool) {
  34   LIR_Opr opr = LIR_OprFact::illegalOpr;
  35   VMReg r_1 = reg-&gt;first();
  36   VMReg r_2 = reg-&gt;second();
  37   if (r_1-&gt;is_stack()) {
  38     // Convert stack slot to an SP offset
  39     // The calling convention does not count the SharedRuntime::out_preserve_stack_slots() value
  40     // so we must add it in here.
  41     int st_off = (r_1-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;
  42     opr = LIR_OprFact::address(new LIR_Address(rsp_opr, st_off, type));
  43   } else if (r_1-&gt;is_Register()) {
  44     Register reg = r_1-&gt;as_Register();
  45     if (r_2-&gt;is_Register() &amp;&amp; (type == T_LONG || type == T_DOUBLE)) {
  46       Register reg2 = r_2-&gt;as_Register();
  47 #ifdef _LP64
  48       assert(reg2 == reg, "must be same register");
  49       opr = as_long_opr(reg);
  50 #else
  51       opr = as_long_opr(reg2, reg);
  52 #endif // _LP64
  53     } else if (is_reference_type(type)) {
  54       opr = as_oop_opr(reg);
  55     } else if (type == T_METADATA) {
  56       opr = as_metadata_opr(reg);
  57     } else if (type == T_ADDRESS) {
  58       opr = as_address_opr(reg);
  59     } else {
  60       opr = as_opr(reg);
  61     }
  62   } else if (r_1-&gt;is_FloatRegister()) {
  63     assert(type == T_DOUBLE || type == T_FLOAT, "wrong type");
  64     int num = r_1-&gt;as_FloatRegister()-&gt;encoding();
  65     if (type == T_FLOAT) {
  66       opr = LIR_OprFact::single_fpu(num);
  67     } else {
  68       opr = LIR_OprFact::double_fpu(num);
  69     }
  70   } else if (r_1-&gt;is_XMMRegister()) {
  71     assert(type == T_DOUBLE || type == T_FLOAT, "wrong type");
  72     int num = r_1-&gt;as_XMMRegister()-&gt;encoding();
  73     if (type == T_FLOAT) {
  74       opr = LIR_OprFact::single_xmm(num);
  75     } else {
  76       opr = LIR_OprFact::double_xmm(num);
  77     }
  78   } else {
  79     ShouldNotReachHere();
  80   }
  81   return opr;
  82 }
  83 
  84 
  85 LIR_Opr FrameMap::rsi_opr;
  86 LIR_Opr FrameMap::rdi_opr;
  87 LIR_Opr FrameMap::rbx_opr;
  88 LIR_Opr FrameMap::rax_opr;
  89 LIR_Opr FrameMap::rdx_opr;
  90 LIR_Opr FrameMap::rcx_opr;
  91 LIR_Opr FrameMap::rsp_opr;
  92 LIR_Opr FrameMap::rbp_opr;
  93 
  94 LIR_Opr FrameMap::receiver_opr;
  95 
  96 LIR_Opr FrameMap::rsi_oop_opr;
  97 LIR_Opr FrameMap::rdi_oop_opr;
  98 LIR_Opr FrameMap::rbx_oop_opr;
  99 LIR_Opr FrameMap::rax_oop_opr;
 100 LIR_Opr FrameMap::rdx_oop_opr;
 101 LIR_Opr FrameMap::rcx_oop_opr;
 102 
 103 LIR_Opr FrameMap::rsi_metadata_opr;
 104 LIR_Opr FrameMap::rdi_metadata_opr;
 105 LIR_Opr FrameMap::rbx_metadata_opr;
 106 LIR_Opr FrameMap::rax_metadata_opr;
 107 LIR_Opr FrameMap::rdx_metadata_opr;
 108 LIR_Opr FrameMap::rcx_metadata_opr;
 109 
 110 LIR_Opr FrameMap::long0_opr;
 111 LIR_Opr FrameMap::long1_opr;
 112 LIR_Opr FrameMap::fpu0_float_opr;
 113 LIR_Opr FrameMap::fpu0_double_opr;
 114 LIR_Opr FrameMap::xmm0_float_opr;
 115 LIR_Opr FrameMap::xmm0_double_opr;
 116 
 117 #ifdef _LP64
 118 
 119 LIR_Opr  FrameMap::r8_opr;
 120 LIR_Opr  FrameMap::r9_opr;
 121 LIR_Opr FrameMap::r10_opr;
 122 LIR_Opr FrameMap::r11_opr;
 123 LIR_Opr FrameMap::r12_opr;
 124 LIR_Opr FrameMap::r13_opr;
 125 LIR_Opr FrameMap::r14_opr;
 126 LIR_Opr FrameMap::r15_opr;
 127 
 128 // r10 and r15 can never contain oops since they aren't available to
 129 // the allocator
 130 LIR_Opr  FrameMap::r8_oop_opr;
 131 LIR_Opr  FrameMap::r9_oop_opr;
 132 LIR_Opr FrameMap::r11_oop_opr;
 133 LIR_Opr FrameMap::r12_oop_opr;
 134 LIR_Opr FrameMap::r13_oop_opr;
 135 LIR_Opr FrameMap::r14_oop_opr;
 136 
 137 LIR_Opr  FrameMap::r8_metadata_opr;
 138 LIR_Opr  FrameMap::r9_metadata_opr;
 139 LIR_Opr FrameMap::r11_metadata_opr;
 140 LIR_Opr FrameMap::r12_metadata_opr;
 141 LIR_Opr FrameMap::r13_metadata_opr;
 142 LIR_Opr FrameMap::r14_metadata_opr;
 143 #endif // _LP64
 144 
 145 LIR_Opr FrameMap::_caller_save_cpu_regs[] = { 0, };
 146 LIR_Opr FrameMap::_caller_save_fpu_regs[] = { 0, };
 147 LIR_Opr FrameMap::_caller_save_xmm_regs[] = { 0, };
 148 
 149 XMMRegister FrameMap::_xmm_regs [] = { 0, };
 150 
 151 XMMRegister FrameMap::nr2xmmreg(int rnr) {
 152   assert(_init_done, "tables not initialized");
 153   return _xmm_regs[rnr];
 154 }
 155 
 156 //--------------------------------------------------------
 157 //               FrameMap
 158 //--------------------------------------------------------
 159 
 160 void FrameMap::initialize() {
 161   assert(!_init_done, "once");
 162 
 163   assert(nof_cpu_regs == LP64_ONLY(16) NOT_LP64(8), "wrong number of CPU registers");
 164   map_register(0, rsi);  rsi_opr = LIR_OprFact::single_cpu(0);
 165   map_register(1, rdi);  rdi_opr = LIR_OprFact::single_cpu(1);
 166   map_register(2, rbx);  rbx_opr = LIR_OprFact::single_cpu(2);
 167   map_register(3, rax);  rax_opr = LIR_OprFact::single_cpu(3);
 168   map_register(4, rdx);  rdx_opr = LIR_OprFact::single_cpu(4);
 169   map_register(5, rcx);  rcx_opr = LIR_OprFact::single_cpu(5);
 170 
 171 #ifndef _LP64
 172   // The unallocatable registers are at the end
 173   map_register(6, rsp);
 174   map_register(7, rbp);
 175 #else
 176   map_register( 6, r8);    r8_opr = LIR_OprFact::single_cpu(6);
 177   map_register( 7, r9);    r9_opr = LIR_OprFact::single_cpu(7);
 178   map_register( 8, r11);  r11_opr = LIR_OprFact::single_cpu(8);
 179   map_register( 9, r13);  r13_opr = LIR_OprFact::single_cpu(9);
 180   map_register(10, r14);  r14_opr = LIR_OprFact::single_cpu(10);
 181   // r12 is allocated conditionally. With compressed oops it holds
 182   // the heapbase value and is not visible to the allocator.
 183   map_register(11, r12);  r12_opr = LIR_OprFact::single_cpu(11);
 184   // The unallocatable registers are at the end
 185   map_register(12, r10);  r10_opr = LIR_OprFact::single_cpu(12);
 186   map_register(13, r15);  r15_opr = LIR_OprFact::single_cpu(13);
 187   map_register(14, rsp);
 188   map_register(15, rbp);
 189 #endif // _LP64
 190 
 191 #ifdef _LP64
 192   long0_opr = LIR_OprFact::double_cpu(3 /*eax*/, 3 /*eax*/);
 193   long1_opr = LIR_OprFact::double_cpu(2 /*ebx*/, 2 /*ebx*/);
 194 #else
 195   long0_opr = LIR_OprFact::double_cpu(3 /*eax*/, 4 /*edx*/);
 196   long1_opr = LIR_OprFact::double_cpu(2 /*ebx*/, 5 /*ecx*/);
 197 #endif // _LP64
 198   fpu0_float_opr   = LIR_OprFact::single_fpu(0);
 199   fpu0_double_opr  = LIR_OprFact::double_fpu(0);
 200   xmm0_float_opr   = LIR_OprFact::single_xmm(0);
 201   xmm0_double_opr  = LIR_OprFact::double_xmm(0);
 202 
 203   _caller_save_cpu_regs[0] = rsi_opr;
 204   _caller_save_cpu_regs[1] = rdi_opr;
 205   _caller_save_cpu_regs[2] = rbx_opr;
 206   _caller_save_cpu_regs[3] = rax_opr;
 207   _caller_save_cpu_regs[4] = rdx_opr;
 208   _caller_save_cpu_regs[5] = rcx_opr;
 209 
 210 #ifdef _LP64
 211   _caller_save_cpu_regs[6]  = r8_opr;
 212   _caller_save_cpu_regs[7]  = r9_opr;
 213   _caller_save_cpu_regs[8]  = r11_opr;
 214   _caller_save_cpu_regs[9]  = r13_opr;
 215   _caller_save_cpu_regs[10] = r14_opr;
 216   _caller_save_cpu_regs[11] = r12_opr;
 217 #endif // _LP64
 218 
 219 
 220   _xmm_regs[0] = xmm0;
 221   _xmm_regs[1] = xmm1;
 222   _xmm_regs[2] = xmm2;
 223   _xmm_regs[3] = xmm3;
 224   _xmm_regs[4] = xmm4;
 225   _xmm_regs[5] = xmm5;
 226   _xmm_regs[6] = xmm6;
 227   _xmm_regs[7] = xmm7;
 228 
 229 #ifdef _LP64
 230   _xmm_regs[8]   = xmm8;
 231   _xmm_regs[9]   = xmm9;
 232   _xmm_regs[10]  = xmm10;
 233   _xmm_regs[11]  = xmm11;
 234   _xmm_regs[12]  = xmm12;
 235   _xmm_regs[13]  = xmm13;
 236   _xmm_regs[14]  = xmm14;
 237   _xmm_regs[15]  = xmm15;
 238   _xmm_regs[16]  = xmm16;
 239   _xmm_regs[17]  = xmm17;
 240   _xmm_regs[18]  = xmm18;
 241   _xmm_regs[19]  = xmm19;
 242   _xmm_regs[20]  = xmm20;
 243   _xmm_regs[21]  = xmm21;
 244   _xmm_regs[22]  = xmm22;
 245   _xmm_regs[23]  = xmm23;
 246   _xmm_regs[24]  = xmm24;
 247   _xmm_regs[25]  = xmm25;
 248   _xmm_regs[26]  = xmm26;
 249   _xmm_regs[27]  = xmm27;
 250   _xmm_regs[28]  = xmm28;
 251   _xmm_regs[29]  = xmm29;
 252   _xmm_regs[30]  = xmm30;
 253   _xmm_regs[31]  = xmm31;
 254 #endif // _LP64
 255 
 256   for (int i = 0; i &lt; 8; i++) {
 257     _caller_save_fpu_regs[i] = LIR_OprFact::single_fpu(i);
 258   }
 259 
 260   int num_caller_save_xmm_regs = get_num_caller_save_xmms();
 261   for (int i = 0; i &lt; num_caller_save_xmm_regs; i++) {
 262     _caller_save_xmm_regs[i] = LIR_OprFact::single_xmm(i);
 263   }
 264 
 265   _init_done = true;
 266 
 267   rsi_oop_opr = as_oop_opr(rsi);
 268   rdi_oop_opr = as_oop_opr(rdi);
 269   rbx_oop_opr = as_oop_opr(rbx);
 270   rax_oop_opr = as_oop_opr(rax);
 271   rdx_oop_opr = as_oop_opr(rdx);
 272   rcx_oop_opr = as_oop_opr(rcx);
 273 
 274   rsi_metadata_opr = as_metadata_opr(rsi);
 275   rdi_metadata_opr = as_metadata_opr(rdi);
 276   rbx_metadata_opr = as_metadata_opr(rbx);
 277   rax_metadata_opr = as_metadata_opr(rax);
 278   rdx_metadata_opr = as_metadata_opr(rdx);
 279   rcx_metadata_opr = as_metadata_opr(rcx);
 280 
 281   rsp_opr = as_pointer_opr(rsp);
 282   rbp_opr = as_pointer_opr(rbp);
 283 
 284 #ifdef _LP64
 285   r8_oop_opr = as_oop_opr(r8);
 286   r9_oop_opr = as_oop_opr(r9);
 287   r11_oop_opr = as_oop_opr(r11);
 288   r12_oop_opr = as_oop_opr(r12);
 289   r13_oop_opr = as_oop_opr(r13);
 290   r14_oop_opr = as_oop_opr(r14);
 291 
 292   r8_metadata_opr = as_metadata_opr(r8);
 293   r9_metadata_opr = as_metadata_opr(r9);
 294   r11_metadata_opr = as_metadata_opr(r11);
 295   r12_metadata_opr = as_metadata_opr(r12);
 296   r13_metadata_opr = as_metadata_opr(r13);
 297   r14_metadata_opr = as_metadata_opr(r14);
 298 #endif // _LP64
 299 
 300   VMRegPair regs;
 301   BasicType sig_bt = T_OBJECT;
 302   SharedRuntime::java_calling_convention(&amp;sig_bt, &amp;regs, 1, true);
 303   receiver_opr = as_oop_opr(regs.first()-&gt;as_Register());
 304 
 305 }
 306 
 307 
 308 Address FrameMap::make_new_address(ByteSize sp_offset) const {
 309   // for rbp, based address use this:
 310   // return Address(rbp, in_bytes(sp_offset) - (framesize() - 2) * 4);
 311   return Address(rsp, in_bytes(sp_offset));
 312 }
 313 
 314 
 315 // ----------------mapping-----------------------
 316 // all mapping is based on rbp, addressing, except for simple leaf methods where we access
 317 // the locals rsp based (and no frame is built)
 318 
 319 
 320 // Frame for simple leaf methods (quick entries)
 321 //
 322 //   +----------+
 323 //   | ret addr |   &lt;- TOS
 324 //   +----------+
 325 //   | args     |
 326 //   | ......   |
 327 
 328 // Frame for standard methods
 329 //
 330 //   | .........|  &lt;- TOS
 331 //   | locals   |
 332 //   +----------+
 333 //   | old rbp,  |  &lt;- EBP
 334 //   +----------+
 335 //   | ret addr |
 336 //   +----------+
 337 //   |  args    |
 338 //   | .........|
 339 
 340 
 341 // For OopMaps, map a local variable or spill index to an VMRegImpl name.
 342 // This is the offset from sp() in the frame of the slot for the index,
 343 // skewed by VMRegImpl::stack0 to indicate a stack location (vs.a register.)
 344 //
 345 //           framesize +
 346 //           stack0         stack0          0  &lt;- VMReg
 347 //             |              | &lt;registers&gt; |
 348 //  ...........|..............|.............|
 349 //      0 1 2 3 x x 4 5 6 ... |                &lt;- local indices
 350 //      ^           ^        sp()                 ( x x indicate link
 351 //      |           |                               and return addr)
 352 //  arguments   non-argument locals
 353 
 354 
 355 VMReg FrameMap::fpu_regname (int n) {
 356   // Return the OptoReg name for the fpu stack slot "n"
 357   // A spilled fpu stack slot comprises to two single-word OptoReg's.
 358   return as_FloatRegister(n)-&gt;as_VMReg();
 359 }
 360 
 361 LIR_Opr FrameMap::stack_pointer() {
 362   return FrameMap::rsp_opr;
 363 }
 364 
 365 // JSR 292
 366 // On x86, there is no need to save the SP, because neither
 367 // method handle intrinsics, nor compiled lambda forms modify it.
 368 LIR_Opr FrameMap::method_handle_invoke_SP_save_opr() {
 369   return LIR_OprFact::illegalOpr;
 370 }
 371 
 372 bool FrameMap::validate_frame() {
 373   return true;
 374 }
</pre></body></html>
